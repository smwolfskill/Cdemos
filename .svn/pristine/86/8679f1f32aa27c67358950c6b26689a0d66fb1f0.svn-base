/**
 * Parallel Make
 * CS 241 - Fall 2016
 */
#include <unistd.h> //for getopt
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <pthread.h>
#include "parmake.h"
#include "parser.h"
#include "queue.h"
typedef struct myQueue { //expanded upon queue_t; like inheritance
	queue_t * queue;
	size_t items; //# items currently has. DO NOT r/w directly!
	short doneInsert; //boolean for if we're done inserting to queue; all items have been added
	pthread_mutex_t m;
} myQueue_t;

myQueue_t * myQueue_create(void *(*copy_constructor_type)(void *), void (*destructor_type)(void *)) {
	myQueue_t * newQueue = malloc(sizeof(myQueue_t));
	newQueue->queue = queue_create(0, copy_constructor_type, destructor_type); //assume maxItems=0 means no limit
	newQueue->items = 0;
	newQueue->doneInsert = 0;
	pthread_mutex_init(&newQueue->m, NULL);
	return newQueue;
}

//Will pull ONLY if items > 0. 
//  If items == 0 and doneInsert == 1, returns NULL.
//	  This is to prevent infinite waiting/blocking on regular queue_t pull.
//	Else, wait to pull.
//	  This is regular queue behavior; want wait to pull if haven't added
//	  everything to the queue yet.
void* myQueue_tryPull(myQueue_t * myQueue) {
	//keep locked whole time to prevent race conditions
	pthread_mutex_lock(&myQueue->m);
	if(myQueue->items == 0 && myQueue->doneInsert) {
		pthread_mutex_unlock(&myQueue->m);
		return NULL; //no items left and done inserting; do nothing
	}
	void * data = queue_pull(myQueue->queue);
	myQueue->items--;
	pthread_mutex_unlock(&myQueue->m);
	return data;
}

//Call w/ doneInsert=0 unless know it's the last thing to insert to queue!
void myQueue_push(myQueue_t * myQueue, void* data, short doneInsert) {
	queue_push(myQueue->queue, data);
	if(doneInsert) {
		pthread_mutex_lock(&myQueue->m);
		myQueue->doneInsert = doneInsert;
		pthread_mutex_unlock(&myQueue->m);
	}
}

//Destroys the inner queue and frees (myQueue)
void myQueue_destroy(myQueue_t * myQueue) {
	queue_destroy(myQueue->queue);
	free(myQueue);
}

int numThreads = 1; //default for opt. -j
char* makefile = "./makefile"; //default for opt. -f. If DNE, try "./Makefile"
char** targets = NULL; //last option
int numTargets = 0;
myQueue_t * queue = NULL;


int stringToInt(char* str) { //only works for positive ints, but that's all we need
	int len = strlen(str);
	int i = len - 1;
	int mul = 1;
	int num = 0;
	while(i >= 0) {
		num += mul * ((int) str[i] - (int) '0');
		i--;
		mul *= 10;
	}
	return num;
}

void myParser(rule_t * rule) {
	//TODO: How tell when this is last item to push to queue??
	//Dependencies: pointers to actual rules! Very good; not just copies!
	printf("myParser: rule = %s @ %p\n", rule->target, rule);
	size_t size = Vector_size(rule->dependencies);
	size_t i = 0;
	while(i < size) {
		void* cur = Vector_get(rule->dependencies, i);
		printf("\tdependencies[%lu] = %s @ %p\n", i, ((rule_t*)cur)->target, cur);
		i++;
	}
	myQueue_push(queue, (void*) rule, 0);
}

void* work(void* arg) { //worker thread
	arg = arg;
	/*rule_t * rule = (rule_t*) myQueue_tryPull(queue);
	while(rule) {
		//TODO:
		
		
		rule = (rule_t*) myQueue_tryPull(queue);
	}*/
	return NULL;
}

void* copy_ctor(void* source) {
	rule_t * copy = malloc(sizeof(rule_t));
	rule_soft_copy(copy, (rule_t*) source);
	return (void*) copy;
}

void dtor(void* toFree) {
	rule_destroy((rule_t*) toFree);
}

// Treat this as main
int parmake(int argc, char **argv) {
	//opterr = 0; //set to 0 if don't want getopt to print err msgs
	//1. Get arguments using getopt
	int c;
	short argF = 0;
	while ((c = getopt (argc, argv, "f:j:")) != -1) {
		switch (c) {
			case 'f': makefile = optarg;
					argF = 1;
					break;
			case 'j': //numThreads = (int) optarg[0] - ((int) '0');
					numThreads = stringToInt(optarg);
					break;
		}
	}
	//1.1 Get optional target arg(s) manually
	int i = optind;
	numTargets = argc-optind;
	int targetIndex = 0;
	while(i < argc) {
		if(!targets) targets = malloc(numTargets*sizeof(char*));
		targets[targetIndex] = argv[i];
		//printf("target %d: %s;\n", targetIndex, targets[targetIndex]);
		i++;
		targetIndex++;
	}
	printf("input: numThreads = %d; makefile = %s; numTargets = %d\n", numThreads, makefile, numTargets);
	//1.2 Error-checking: Make sure can open/read Makefile
	FILE* makeFd = fopen(makefile, "r");
	if(!makeFd) {
		if(argF) {
			fprintf(stderr, "Cannot open/read specified Makefile '%s'. Done.\n", makefile);
			return 1; //cannot open/read user-specified Makefile
		}
		makefile = "./Makefile";
		makeFd = fopen(makefile, "r");
		if(!makeFd) {
			fprintf(stderr, "'./makefile' and './Makefile' not found; did you mean to specify one?\nUsage: ./parmake -f <Makefile> -j <numThreads> <target1> ...\n");
			return 2; //"./makefile" and "./Makefile" DNE
		}
	}
	printf("Success opening '%s'.\n", makefile);
	fclose(makeFd);
	//2. Create threads and parse makefile target(s)
	queue = myQueue_create(copy_ctor, dtor);
	pthread_t tids[numThreads];
	i = 0;
	while(i < numThreads) {
		pthread_create(&tids[i], NULL, work, NULL);
		i++;
	}
	parser_parse_makefile(/*(const char*)*/makefile, targets, myParser);
	//3. Wait for threads to finish; done
	i = 0;
	while(i < numThreads) {
		pthread_join(tids[i], NULL); //TODO: need ret. val?
		i++;
	}
	myQueue_destroy(queue);
	return 0;
}
