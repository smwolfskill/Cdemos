/**
 * Machine Problem: Shell
 * CS 241 - Fall 2016
 */
#include <stdio.h>
#include <string.h>
#include <unistd.h> //for getpid, access
#include <stdlib.h> //for getenv

#include "format.h"
#include "log.h"
#include "shell.h"

extern char ** environ;

//TODO: want shell to ignore Ctrl+C signal (SIGINT). Shell should NOT exit upon receiving SIGINT.

void printHistory(Log * log) { //simple helper fxn to make doCommand more readable
	size_t logSize = Log_size(log);
	size_t i = 0;
	while(i < logSize) {
		print_history_line(i, Log_get_command(log, i));
		i++;
	}
}

short doCommand(Log * log, FILE * fd) { //Returns false if EOF. (fd) is stdin normally
	//Prepare for next command: get more input, and delimit it:
		short success = 1;
		short addToLog = 1;
  	print_prompt(getenv("PWD"), getpid());
		char * input = NULL; //for current line of input
  	size_t capacity = 0;
		char ** args = NULL; //for delimiting input
  	size_t numArgs = 0;
		//1. Get current line of input:
  	ssize_t result = getline(&input, &capacity, fd);
  	if(result == -1) { //quit if EOF
			//printf("EOF!\n");
			success = 0;
		} else if(result > 0) {
			if(input[result-1]=='\n') input[result-1] = '\0'; //replace terminating '\n' with '\0' which is much more useful
			//printf("just entered:%s;\n", input);
			//2. Delimit it (spaces):
			args = strsplit(input, " ", &numArgs);
			//3. Execute command:
			if(!strcmp(input, "!history")) { //built-in cmd: Print out history in order
				printHistory(log);
				addToLog = 0;
			} else {
				
			}
		}
	if(addToLog && success) Log_add_command(log, input); //only don't when command is "!history" or EOF
	//Only for external commands:
	//print_command_executed(/*processID*/);
	//Clean-up:
	free(input);
  if(args != NULL) free_args(args);
	return success;
}

int shell(int argc, char *argv[]) {
  print_shell_owner("wolfski2");
	int exitSignal = 0;
  Log * log = NULL;
  char * histFile = NULL;
  short hCmd = 0; //if used that command before (don't want it twice!)
  short fCmd = 0;
  if(argc != 1 && argc != 3 && argc != 5) { print_usage(); exit(1); }
  else {
  	int i = 1;
  	while(i < argc) {
  		if(!strcmp(argv[i], "-h") && !hCmd) {
  			if(access(argv[i+1], F_OK) == -1) print_history_file_error(); //file DNE
  			else histFile = argv[i+1];
  			log = Log_create_from_file(argv[i+1]);
  			hCmd = 1;
 	 		} else if (!strcmp(argv[i], "-f") && !fCmd) {
  			if(access(argv[i+1], F_OK) == -1) { //file DNE
					print_script_file_error();
					exitSignal = 1;
				} else { //parse file argv[i+1]; each line is treated as a command
  				FILE * fd = fopen(argv[i+1], "r");
					while(doCommand(log, fd));
					fclose(fd);
				}
  			fCmd = 1;
  		} else { print_usage(); exitSignal = 1;}
  		i += 2;
  	}
  }
  if(!hCmd) log = Log_create();
  //printf("log size = %lu\n", Log_size(log));
  while(!exitSignal && !fCmd && doCommand(log, stdin)); //don't want to run if already ran command file or error
  //Finishing up:
  if(histFile) Log_save(log, histFile);
	free(histFile);
  free(log);
  print_command(""); //not sure if necessary, just looks better. Hope no points lost...
  return exitSignal;
}
