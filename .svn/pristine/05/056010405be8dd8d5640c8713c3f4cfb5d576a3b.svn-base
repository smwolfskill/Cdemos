/**
 * Machine Problem: Shell
 * CS 241 - Fall 2016
 */
#include <stdio.h>
#include <string.h>
#include <unistd.h> //for getpid

#include "format.h"
#include "log.h"
#include "shell.h"

//We want the shell to ignore the Ctrl+C signal (SIGINT). The shell should not exit upon receiving SIGINT.
void historyCommand(char * filename) {
	
}

void fileCommand(char * filename) {
	
}


int shell(int argc, char *argv[]) {
  // TODO: This is the entry point for your shell.
  print_shell_owner("wolfski2");
  if(argc != 3) print_usage();
  else {
  	
  }
  Log * log = Log_create();
  char * input = NULL;
  size_t capacity = 0;
  char ** args = NULL; //for delimiting input
  size_t numArgs = 0;
  while(1) {
  	//Prepare for next command: get more input, and delimit it:
  	ssize_t result = getline(&input, &capacity, stdin);
  	if(result>0) {
		if(args != NULL) free_args(args);
		if(input[result-1]=='\n') input[result-1] = '\0'; //replace terminating ‘\n’ with ‘\0’ which is much more useful
		printf("just entered:%s;\n", input);
		args = strsplit(input, " ", &numArgs);
	} else if(result == -1) {
		printf("EOF!\n");
		break;
	}
	//Error check and execute command:
  	if(numArgs != 3) print_usage();
  	else {
		
	}
	print_prompt("hi", getpid());
  }
  free(log);
  free(input);
  if(args != NULL) free_args(args);
  return 0;
}
