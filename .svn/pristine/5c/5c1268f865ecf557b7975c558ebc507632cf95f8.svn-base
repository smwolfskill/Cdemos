/**
 * Overworked Interns Lab
 * CS 241 - Fall 2016
 */
#include "company.h"
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

typedef struct mutexControl {
	pthread_mutex_t * arbitrator; //controller
	pthread_mutex_t * intern; //ptr to intern we're controlling
	struct mutexControl * next;
} mutexControl_t;

mutexControl_t * head;
mutexControl_t * tail;

mutexControl_t * mutexControl_tryInsert(pthread_mutex_t * intern) {
	//TODO: Don't insert if intern is already part of the LL!
	//1. Search LL to see if intern is already in it, and if so, return the mutexControl that has it
	short alreadyExists = 0; //if intern is already part of LL
	mutexControl_t * cur = head;
	while(cur) {
		//Compare addresses
		if(cur->intern == intern) { alreadyExists = 1; break; }
		cur = cur->next;
	}
	if(alreadyExists) return cur;
	//2. Doesn't exist already, so add it to LL:
	mutexControl_t * control = malloc(sizeof(mutexControl_t));
	pthread_mutex_init(control->arbitrator, NULL);
	control->intern = intern;
	//3. (LL things: set head, tail->next, tail):
	if(!head) head = control;
	if(tail) tail->next = control;
	tail = control;
	return control;
}

mutexControl_t * mutexControl_tryDestroy(mutexControl_t * toDestroy) {
	//TODO: destroy this if not already destroyed!
}

//If frozen in terminal, try CTRL + \  (backslash)
//MAKE SURE not to unlock mutexes that aren't locked! BAD
void *work_interns(void *p) {
	Company * company = (Company*) p;
	pthread_mutex_t * Lintern = Company_get_left_intern(company);
    pthread_mutex_t * Rintern = Company_get_right_intern(company);
    //TODO: consider not having ref. to L,Rintern and using solely mutexControl.
    //		(would need to add more fxns.)
    mutexControl_t * Lintern_ctrl = mutexControl_tryInsert(Lintern);
    mutexControl_t * Rintern_ctrl = mutexControl_tryInsert(Rintern);
	int notAcquired;
	while(running) {
		if(Lintern != Company_get_left_intern(company)) printf("Company w/ tid%d LEFT intern changed!\n", Company_get_tid(company));
		if(Rintern != Company_get_right_intern(company)) printf("Company w/ tid%d RIGHT intern changed!\n", Company_get_tid(company));
    	notAcquired = 1;//1 means haven't acquired BOTH interns
		//Now differs from bad_company.c:
		//  Deadlock sol'n: Can't break Mutual Exclusion. Can't break Circular Wait.
		//	  Can't foreseeably break No pre-emption. So MUST BREAK Hold&Wait.
		//		Use pthread_mutex_trylock(): returns 0 if lock is acquired, else
		//		returns other int and doesn't wait.
		//	  So try locking left, and if success, try lock right. 
		//	  If can't lock right, release left.
		//		-This should solve deadlock; I just fear for livelock.
		if(!pthread_mutex_trylock(Lintern)) { //locked left
			notAcquired = pthread_mutex_trylock(Rintern); //put acquired last to prevent compiler optimization not evaulating RHS of || if LHS == 1
			if(notAcquired) {
				pthread_mutex_unlock(Lintern);
				//TODO: to prevent starvation, add to queue? Arbitrator?
				
			}
		}
		
		if(!notAcquired) { //Acquired both interns
			Company_hire_interns(company); //call once locked both interns
			pthread_mutex_unlock(Rintern);
			pthread_mutex_unlock(Lintern);
		}
	}
	//TODO: destroy mutexControls
	return NULL;
}
