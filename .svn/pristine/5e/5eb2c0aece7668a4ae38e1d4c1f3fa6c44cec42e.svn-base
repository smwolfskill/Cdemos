/**
 * Machine Problem: Vector
 * CS 241 - Fall 2016
 */

/* An automatically-expanding array of strings. */
#include "vector.h"
#include <assert.h>
#include <stdio.h>
#include <string.h>

#define INITIAL_CAPACITY 10

/*
 * Vector structure
 * Do not modify the structure
 * array: Void pointer to the beginning of an array of void pointers to
 * arbitrary data.
 * size: The number of elements in the vector. This is the number of actual
 * objects held in the vector, which is not necessarily equal to its capacity.
 * capacity: The size of the storage space currently allocated for the vector,
 * expressed in terms of elements.
 * copyt_constructor: the function callback for you to define the way you want
 * to copy elements
 * destructor:  the function callback for you to define the way you want to
 * destroy elements
 */
struct Vector {
  copy_constructor_type copy_constructor;
  destructor_type destructor;

  void **array;
  size_t size;
  size_t capacity;
};

Vector *Vector_create(copy_constructor_type copy_constructor,
                      destructor_type destructor) {
  // your code here
  Vector * newVec = malloc(sizeof(Vector));
  newVec->copy_constructor = copy_constructor;
  newVec->destructor = destructor;
  newVec->size = 0;
  newVec->capacity = 10;
  while(newVec->size < newVec->capacity) newVec->array[newVec->size++] = NULL;
  newVec->size = 0;
  return newVec;
}

//In C there is no 'this', so have to pass in ptr to it in every function
void Vector_destroy(Vector *vector) { //I think done
  assert(vector);
  // your code here
  size_t i = 0;
  while(i < vector->size) {
  	if(vector->array[i]) vector->destructor(vector->array[i++]); //don't call when NULL
  }
  //don't assume nothing bad happens when call destructor(NULL) !!
}

size_t Vector_size(Vector *vector) { //I think done
  assert(vector);
  // your code here
  return vector->size;
}

size_t Vector_capacity(Vector *vector) {
  assert(vector);
  // your code here
  return vector->capacity;
}

void Vector_resize(Vector *vector, size_t new_size) {
  assert(vector);
  // your code here
  //Double or halve capacity depending on new_size, realloc, and initialize
  size_t oldCapacity = vector->capacity;
  while(new_size > vector->capacity) {
  	vector->capacity *= 2;
  }
  while(4 * new_size <= vector->capacity) {
  	if((vector->capacity / 2) < 10) {
  		vector->capacity = 10; //10 capacity minimum
  		break;
  	} else vector->capacity /= 2;
  }
  if(oldCapacity != vector->capacity) { //changed capacity
  	vector->array = realloc(vector->array, vector->capacity * sizeof(void*));
  	size_t i = oldCapacity - 1;
  	while(i < vector->capacity) vector->array[i++] = NULL; //new entries are initialized to NULL
  }
  return;
}

void Vector_set(Vector *vector, size_t index, void *elem) {
  assert(vector);
  // your code here
  if(elem != NULL) vector->size++;
}

void *Vector_get(Vector *vector, size_t index) {
  assert(vector);
  // your code here
  return NULL;
}

void Vector_insert(Vector *vector, size_t index, void *elem) {
  assert(vector);
  // your code here
}

void Vector_delete(Vector *vector, size_t index) {
  assert(vector);
  // your code here, what asserts might you want?
}

void Vector_append(Vector *vector, void *elem) {
  assert(vector);
  // your code here
}
