/**
 * Ideal Indirection Lab
 * CS 241 - Fall 2016
 */
#include "kernel.h"
#include "mmu.h"
#include <assert.h>
#include <stdio.h>

MMU *MMU_create() {
  MMU *mmu = calloc(1, sizeof(MMU));
  mmu->tlb = TLB_create();
  mmu->curr_pid = 0;
  return mmu;
}

void * maskVirtualAddress(void * virtual_address, int lowestBitsKeep) {
	unsigned long long mask = 1;
	for(int i = 0; i < lowestBitsKeep; i++) {
		mask *= 2;
	}
	mask--;
	return (void*) ((unsigned long long) virtual_address & mask);
}

void *MMU_get_physical_address(MMU *mmu, void *virtual_address, size_t pid) {
  assert(pid < MAX_PROCESS_ID);
  void * maskedVA = maskVirtualAddress(virtual_address, VIRTUAL_ADDRESS_LENGTH);
  void * physical = NULL;
  if(pid != mmu->curr_pid) { //different pid than before
  	TLB_flush(&mmu->tlb); //for security, flush TLB
  	mmu->curr_pid = pid;
  }
  else { //check TLB: much faster if it has it
  	physical = TLB_get_physical_address(&mmu->tlb, maskedVA);
  	if(physical) return physical;
  }
  //Not in TLB; search PageTables
  MMU_tlb_miss(mmu, virtual_address, pid); //tlb doesn't have it
  //size_t offset = (size_t) maskVirtualAddress(virtual_address, OFFSET_LENGTH);
  //TODO: Uncomment these two ^ v out, and traverse all 3 PageTable levels.
  //	TODO: Add to TLB cache when done!!!
  //physical = PageTable_get_entry(mmu->base_pts[pid], offset); //only use on vpn3
  return physical;
}

void MMU_tlb_miss(MMU *mmu, void *address, size_t pid) {
  assert(pid < MAX_PROCESS_ID);
  mmu->num_tlb_misses++;
  printf("Process [%lu] tried to access [%p] and it couldn't find it in the "
         "TLB so the MMU has to check the PAGE TABLES\n",
         pid, address);
}

void MMU_raise_page_fault(MMU *mmu, void *address, size_t pid) {
  assert(pid < MAX_PROCESS_ID);
  mmu->num_page_faults++;
  printf(
      "Process [%lu] tried to access [%p] and the MMU got an invalid entry\n",
      pid, address);
}

void MMU_add_process(MMU *mmu, size_t pid) {
  assert(pid < MAX_PROCESS_ID);
  mmu->base_pts[pid] = PageTable_create();
}

void MMU_free_process_tables(MMU *mmu, size_t pid) {
  assert(pid < MAX_PROCESS_ID);
  PageTable *base_pt = mmu->base_pts[pid];
  Pagetable_delete_tree(base_pt);
}

void MMU_delete(MMU *mmu) {
  for (size_t i = 0; i < MAX_PROCESS_ID; i++) {
    MMU_free_process_tables(mmu, i);
  }
  TLB_delete(mmu->tlb);
  free(mmu);
}
