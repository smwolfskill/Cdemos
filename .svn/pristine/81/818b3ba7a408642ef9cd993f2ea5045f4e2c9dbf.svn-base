/**
 * Mad Mad Access Pattern
 * CS 241 - Fall 2016
 */
#include <string.h>
#include <stdio.h>
#include "tree.h"
#include "utils.h"
/*
  Look up a few nodes in the tree and print the info they contain.
  This version uses fseek() and fread() to access the data.

  ./lookup1 <data_file> <word> [<word> ...]
*/
void printNode(BinaryTreeNode const * const toPrint) {
	printf("PRINTING NODE:\n\tleft_child = %u\n\tright_child = %u\n\tcount = %u\n\tprice = %f\n\tword = %s\n====================\n", toPrint->left_child, toPrint->right_child, toPrint->count, toPrint->price, toPrint->word);
}

void setNode(BinaryTreeNode * const allocatedNode, FILE * f, uint32_t startIndex) {
	if(startIndex != 0) {
		fseek(f, startIndex, SEEK_SET);
		fread(&allocatedNode->left_child, 4, 1, f);
		//fseek(f, 4, SEEK_CUR);
		fread(&allocatedNode->right_child, 4, 1, f);
		//fseek(f, 4, SEEK_CUR);
		fread(&allocatedNode->count, 4, 1, f);
		//fseek(f, 4, SEEK_CUR);
		fread(&allocatedNode->price, 4, 1, f);
		//fseek(f, 4, SEEK_CUR);
		size_t wordLen = 0;
		int c;
		while(1) {
			c = fgetc(f);
			if(c == EOF) break;
			//printf("%c = %d;", c, c);
			//allocatedNode->word = realloc(allocatedNode->word, wordLen);
			allocatedNode->word[wordLen] = (char) c;
			wordLen++;
			if(c == '\0') break;
		}
		printNode(allocatedNode);
	}
}

int main(int argc, char **argv) {
	//Version 1: fseek/fread (NO mmap)
	//printf("strcmp(aaa, baa) = %d; strcmp(aaa, aba) = %d; strcmp(aaa, abb) = %d; strcmp(zeg, aaa) = %d\n", strcmp("aaa", "baa"), strcmp("aaa", "aba"), strcmp("aaa", "bbb"), strcmp("ccc", "aaa"));
	if(argc < 3) {
		printArgumentUsage();
		return 1;
	}
	short readSuccess = 1;
	FILE * f = fopen(argv[1], "r");
	readSuccess = (f != NULL);
	if(readSuccess) {
		char cur[5];
		fseek(f, 0, SEEK_SET);
		if(fread(cur, 1, 4, f) < 4) readSuccess = 0;
		else {
			cur[4] = '\0';
			if(strcmp(cur, "BTRE")) {
				fprintf(stderr, "(1st 4 bytes were %s !)\n", cur);
				readSuccess = 0;
			} else {
				int keywordIndex = 2;
				//BinaryTreeNode cur;
				//setNode(&cur, f, 4);
				while(keywordIndex <= argc) {
					//TODO
					
					keywordIndex++;
				}
			}
		}
	}
	else {
		openFail(argv[1]);
		return 2;
	}
	if(!readSuccess) {
		formatFail(argv[1]);
		return 2;
	}
	return 0;
}
