/**
 * Machine Problem: Shell
 * CS 241 - Fall 2016
 */
#include <stdio.h>
#include <string.h>
#include <unistd.h> //for getpid, access
#include <stdlib.h> //for getenv

#include "format.h"
#include "log.h"
#include "shell.h"

extern char ** environ;

//We want the shell to ignore the Ctrl+C signal (SIGINT). The shell should not exit upon receiving SIGINT.

/*void historyCommand(char * filename) {
	
}

void fileCommand(char * filename) {
	
}*/


int shell(int argc, char *argv[]) {
  // TODO: This is the entry point for your shell.
  print_shell_owner("wolfski2");
  Log * log = NULL;
  char * histFile = NULL;
  short hCmd = 0; //if used that command before (don't want it twice!)
  short fCmd = 0;
  if(argc != 1 && argc != 3 && argc != 5) { print_usage(); exit(1); }
  else {
  	int i = 1;
  	while(i < argc) {
  		if(!strcmp(argv[i], "-h") && !hCmd) {
  			if(access(argv[i+1], F_OK) == -1) print_history_file_error();
  			else histFile = argv[i+1];
  			log = Log_create_from_file(argv[i+1]);
  			hCmd = 1;
 	 	} else if (!strcmp(argv[i], "-f") && !fCmd) {
  			if(access(argv[i+1], F_OK) == -1) print_script_file_error();
  			//TODO: parse argv[i+1] and execute commands sequentially
  			
  			fCmd = 1;
  		} else { print_usage(); exit(1); }
  		i += 2;
  	}
  }
  if(!hCmd) log = Log_create();
  //printf("log size = %lu\n", Log_size(log));
  char * input = NULL;
  size_t capacity = 0;
  char ** args = NULL; //for delimiting input
  size_t numArgs = 0;
  while(1) {
  	//Prepare for next command: get more input, and delimit it:
  	print_prompt(getenv("PWD"), getpid());
  	ssize_t result = getline(&input, &capacity, stdin);
  	if(result>0) {
		if(args != NULL) free_args(args);
		if(input[result-1]=='\n') input[result-1] = '\0'; //replace terminating ‘\n’ with ‘\0’ which is much more useful
		//printf("just entered:%s;\n", input);
		args = strsplit(input, " ", &numArgs);
	} else if(result == -1) {
		//printf("EOF!\n");
		break;
	}
	//execute command:
	
	//Finish up for next iteration:
	Log_add_command(log, input);
	//Only for external commands:
	//print_command_executed(/*processID*/);
  }
  //Finishing up:
  if(histFile) Log_save(log, histFile);
  free(log);
  free(input);
  if(args != NULL) free_args(args);
  print_command("");
  return 0;
}
