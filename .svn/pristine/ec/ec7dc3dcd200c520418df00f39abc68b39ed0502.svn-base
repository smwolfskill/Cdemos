/**
 * Scheduler Lab
 * CS 241 - Fall 2016
 */
#include "libpriqueue.h"
#include "libscheduler.h"

typedef struct _job_t job_t;
typedef struct _core_t core_t;
/**
  Stores information making up a job to be scheduled including any statistics.

  You may need to define some global variables or a struct to store your job
  queue elements.
*/
struct _job_t {
  int id;
  int priority;
  /* Add whatever other bookkeeping you need into this struct: */
  int arrivalTime;
  int burstTime; //est. time it will take to execute
};

struct _core_t {
  int free;   // boolean representing whether the core is in use or not
  job_t *job; // the job that the core is currently running, if any
};

priqueue_t pqueue;
int numCores = 0;
core_t *cores; //array of cores, dynamically allocated. id is index!
scheme_t scheme;

//Pass in job_t * !
int comparer_fcfs(const void *a, const void *b) { //maybe right? in theory?
	job_t * a_job = (job_t*) a;
	job_t * b_job = (job_t*) b;
	if(a_job->arrivalTime == b_job->arrivalTime)
		return 0; //tie
	return (a_job->arrivalTime < b_job->arrivalTime ? -1 : 1); //return -1 if choose 0th param
}

//In a tie, choose fcfs
int break_tie(const void *a, const void *b) { return comparer_fcfs(a, b); }

int comparer_ppri(const void *a, const void *b) {
  //Pre-emptive Priority. Complete as is
  return comparer_pri(a, b);
}

int comparer_pri(const void *a, const void *b) {
	//Priority. Higher value = higher priority, but no pre-emption ?
	
	return 0;
}

int comparer_psjf(const void *a, const void *b) {
	//Pre-emptive shortest-job first.
	//	Interrupted jobs that are shorter than every other placed at queue head!
	
	return comparer_sjb(a, b); //TODO: Maybe?
}

int comparer_rr(const void *a, const void *b) { //TODO: How?
  // Casting to void to silence compiler warning
  (void)a;
  (void)b;
  // Picking 1 arbitarily.
  return 1;
}

int comparer_sjf(const void *a, const void *b) { //think correct. untested
	//Shortest job first. The currently running job will NOT be interrupted.
	job_t * a_job = (job_t*) a;
	job_t * b_job = (job_t*) b;
	if(a_job->burstTime == b_job->burstTime) return break_tie(a, b);
	return ( a_job->burstTime < b_job->burstTime ? -1 : 1); //return -1 if choose 0th param
}

void scheduler_start_up(int numcores, scheme_t s) {
  switch (s) {
  case FCFS:
    priqueue_init(&pqueue, comparer_fcfs);
    break;

  case PRI:
    priqueue_init(&pqueue, comparer_pri);
    break;

  case PPRI:
    priqueue_init(&pqueue, comparer_ppri);
    break;

  case PSJF:
    priqueue_init(&pqueue, comparer_psjf);
    break;

  case RR:
    priqueue_init(&pqueue, comparer_rr);
    break;

  case SJF:
    priqueue_init(&pqueue, comparer_sjf);
    break;

  default:
    printf("Did not recognize scheme\n");
    exit(1);
  }
  //My code: init cores:
  cores = malloc(numcores * sizeof(core_t));
  numCores = numcores;
  int i = 0;
  while(i < numcores) { cores[i].free = 1; cores[i].job = NULL; i++; }
}

int scheduler_new_job(int job_number, int time, int running_time, int priority) {
	//The lower the priority value, the greater the priority!
	job_t * newJob = malloc(sizeof(job_t));
	newJob->id = job_number;
	newJob->arrivalTime = time;
	newJob->burstTime = running_time;
	newJob->priority = priority;
	priqueue_offer(&pqueue, (void*) newJob);
	//1. If there is a free core(s), run it on the lowest index/id core. No waiting, conflicts, interrupts (easy, ideal case).
	int i = 0;
	while(i < numCores) {
		if(cores[i].free) {
			cores[i].job = newJob;
			break;
		}
		i++;
	}
	//2. No free cores, so determine if should interrupt:
	//TODO: Now, determine if need to interrupt:
	
	return i; //TODO: Return index/id of core running job on, or -1 if no scheduling changes
}

int scheduler_job_finished(int core_id, int job_number, int time) {
	//TODO
	
  return 9001;
}

//For Round Robin!!
int scheduler_quantum_expired(int core_id, int time) { return 9001; }

float scheduler_average_waiting_time() { return 9001; }

float scheduler_average_turnaround_time() { return 9001; }

float scheduler_average_response_time() { return 9001; }

void scheduler_clean_up() {
  /* TODO: Do more cleaning up here */
  void * cur = priqueue_poll(priqueue);
  while(cur != NULL) { free(cur); cur = priqueue_poll(priqueue); }
  priqueue_destroy(&pqueue);
  free(cores);
}

void scheduler_show_queue() {
  // This function is left entirely to you! Totally optional.
  //void* cur = priqueue_peek(&pqueue);
  
}
