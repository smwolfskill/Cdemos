/**
 * Machine Problem: Wearables
 * CS 241 - Fall 2016
 */

#include <fcntl.h>
#include <netdb.h>
#include <pthread.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <unistd.h>

#include "utils.h"
#include "vector.h"
#include "wearable.h"

// The wearable server socket, which all wearables connect to.
int wearable_server_fd;
volatile int done = 0;

typedef struct threadData {
  pthread_t thread;
  int fd;
  long timestamp;
  // TODO you might want to put more things here
  struct threadData * next;
} thread_data;

//thread_data ** wearable_threads;
thread_data * wearable_thread_head = NULL;
thread_data * wearable_thread_tail = NULL;
int wearable_threads_size = 0;

//Mine: Create new thread_data as well as start the thread on wearable_processor_thread
thread_data * thread_data_create(int fd, long timestamp) {
	thread_data * newtdata = malloc(sizeof(thread_data));
	newtdata->fd = fd;
	newtdata->timestamp = timestamp;
	//LL things:
	if(!wearable_thread_head) wearable_thread_head = newtdata;
	if(wearable_thread_tail) wearable_thread_tail->next = newtdata;
	wearable_thread_tail = newtdata;
	wearable_threads_size++;
	pthread_create(&newtdata->thread, wearable_processor_thread, (void*)newtdata);
	return newtdata;
}

void thread_data_joinAll() { //mine. wait to join & free all.
	thread_data * cur = wearable_thread_head;
	thread_data * next;
	while(cur) {
		next = cur->next;
		pthread_join(cur->thread, NULL);
		free(cur);
		cur = next;
	}
	wearable_thread_head = NULL;
	wearable_thread_tail = NULL;
}

void signal_received(int sig) {
  // TODO close server socket, free anything you don't free in main
	done = 1;
	close(wearable_server_fd);
	
}

void *wearable_processor_thread(void *args) {
  thread_data *td = (thread_data *)args;
  int socketfd = td->fd;

  // TODO read data from the socket

  close(socketfd);
  return NULL;
}

void *user_request_thread(void *args) {
  int socketfd = *((int *)args);

  // TODO read data from the socket
  // Requests will be in the form "<timestamp1>:<timestamp2>"
  // Write out statistics for data between those timestamp ranges

  close(socketfd);
  return NULL;
}

int open_server_socket(const char *port) { //think done
  // given a string with the port value, set up a passive socket file
  // descriptor and return it
	errno = 0;
	struct addrinfo hints, * result;
	memset(&hints, 0, sizeof(hints)); //make sure no garbage
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;
	int g = getaddrinfo(NULL, port, &hints, &result);
	if(g != 0) { fprintf(stderr, "getaddrinfo: %s\n", gai_strerror(g)); exit(1); }
  /*QUESTION 1, 2, 3*/
	int sockFd = socket(result->ai_family, result->ai_socktype, IPPROTO_TCP); //create endpoint for IPv4 TCP conn.
	if(sockFd == -1) { perror(NULL); exit(1); }
	int optval = 1;
    if(setsockopt(serverSocket, SOL_SOCKET, SO_REUSEPORT, &optval, sizeof(optval)) != 0) { perror(NULL); exit(1); } //want port to be reusable instantaneously
	if(bind(sockFd, result->ai_addr, result->ai_addrlen) != 0) { perror(NULL); exit(1); }
	freeaddrinfo(result);
  return sockFd;
}

int wearable_server(const char *wearable_port, const char *request_port) {
  // setup signal handler for SIGINT
	signal(SIGINT, signal_received);
  int request_server_fd = open_server_socket(request_port);
  wearable_server_fd = open_server_socket(wearable_port);

	if(listen(request_server_fd, 1) != 0) { perror(NULL); exit(1); }

  pthread_t request_thread;
  int request_socket = accept(request_server_fd, NULL, NULL);
  pthread_create(&request_thread, NULL, user_request_thread, &request_socket);
  close(request_server_fd);
  
	if(listen(wearable_server_fd, 128) != 0) { perror(NULL); exit(1); } //TODO:128 right?
	while(!done) {
		// TODO accept continous requests on the wearable port
		
	}
  // TODO join all threads we spawned from the wearables.
	
  // Cleanup anything we've allocated.
  pthread_join(request_thread, NULL);

  return 0;
}
